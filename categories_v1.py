# -*- coding: utf-8 -*-
"""Multinomial Categories.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1760gLSSMSIpRnI6jyUqP1a3jnaC1Cguv

# Multinomial Classification
"""

import numpy as np
import pandas as pd
import lmdb
import os
import pickle
from sklearn.cluster import KMeans
from sklearn import metrics
from scipy.spatial.distance import cdist
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
np.random.seed(123)

"""## Importing Data"""

data_path = 'data'
keys_path = 'data/val_keys.pkl'

env = lmdb.open(os.path.join(data_path, 'val_lmdb'), max_readers=1, readonly=True, lock=False, readahead=False, meminit=False)

ids = pickle.load(open(keys_path, 'rb'))

storage = []
classes = []
def path_for(filename):
  return os.path.join(images_path, filename[0], filename[1], filename[2], filename[3], filename)

for id in ids:
  with env.begin(write=False) as txn:
    byte_sample = txn.get(id.encode())
  sample = pickle.loads(byte_sample, encoding='latin')
  sample.pop('imgs',None)
  sample['intrs'] = np.average(sample['intrs'], axis=0)
  #sample['intrs'] = np.sum(sample['intrs'], axis=0) #I used average instead as it is more recommended on the web
  entry = np.concatenate([sample['ingrs'],sample['intrs']])
  classes.append(sample['classes'])
  storage.append(entry.tolist())

"""## Normalisation"""

df = pd.DataFrame(storage)
scaler = MinMaxScaler()
scaler.fit(df)
df = pd.DataFrame(scaler.transform(df).tolist())

"""## K-Means Clustering"""

distortions = []
K = range(1,20)
for k in K:
    kmeanModel = KMeans(n_clusters=k,max_iter=100,n_init=1).fit(df)
    kmeanModel.fit(df)
    distortions.append(sum(np.min(cdist(df, kmeanModel.cluster_centers_, 'euclidean'), axis=1)) / df.shape[0])

plt.plot(K, distortions, 'bx-')
plt.xlabel('k')
plt.ylabel('Distortion')
plt.title('The Elbow Method showing the optimal k')
plt.show()
#12 clusters

km = KMeans(n_clusters=12,max_iter=100,n_init=1).fit(df)
km.fit(df)
cluster_map = pd.DataFrame()
cluster_map['group'] = classes
cluster_map['cluster'] = km.labels_

"""## Check the main food categories of each cluster, or should we take all?"""

base = cluster_map.groupby("group",as_index=False).count()

group0 = cluster_map[cluster_map.cluster == 0].groupby('group',as_index=False).count()
group0 = pd.merge(group0,base,on='group',how='inner')
group0.columns = ['category', 'count','total']
group0 = group0.sort_values(['count'], ascending=False) #not sure what should be the cut off, should it be based on proportion instead?
#group0["proportion"] = group0["count"]/group0["total"] #To calculate proportion
#group0 = group0.sort_values(['proportion'], ascending=False) 

group1 = cluster_map[cluster_map.cluster == 1].groupby('group',as_index=False).count()
group1 = pd.merge(group1,base,on='group',how='inner')
group1.columns = ['category', 'count','total']
group1 = group1.sort_values(['count'], ascending=False) #not sure what should be the cut off, should it be based on proportion instead?
#group1["proportion"] = group1["count"]/group1["total"]
#group1 = group1.sort_values(['proportion'], ascending=False) 

group2 = cluster_map[cluster_map.cluster == 2].groupby('group',as_index=False).count()
group2 = pd.merge(group2,base,on='group',how='inner')
group2.columns = ['category', 'count','total']
group2 = group1.sort_values(['count'], ascending=False) #not sure what should be the cut off, should it be based on proportion instead?
#group2["proportion"] = group2["count"]/group2["total"]
#group2 = group1.sort_values(['proportion'], ascending=False) 

group3 = cluster_map[cluster_map.cluster == 3].groupby('group',as_index=False).count()
group3 = pd.merge(group3,base,on='group',how='inner')
group3.columns = ['category', 'count','total']
group3 = group1.sort_values(['count'], ascending=False) #not sure what should be the cut off, should it be based on proportion instead?
#group3["proportion"] = group3["count"]/group3["total"]
#group3 = group3.sort_values(['proportion'], ascending=False) 

group4 = cluster_map[cluster_map.cluster == 4].groupby('group',as_index=False).count()
group4 = pd.merge(group4,base,on='group',how='inner')
group4.columns = ['category', 'count','total']
group4 = group4.sort_values(['count'], ascending=False) #not sure what should be the cut off, should it be based on proportion instead?
#group4["proportion"] = group4["count"]/group4["total"]
#group4 = group4.sort_values(['proportion'], ascending=False) 

group5 = cluster_map[cluster_map.cluster == 5].groupby('group',as_index=False).count()
group5 = pd.merge(group5,base,on='group',how='inner')
group5.columns = ['category', 'count','total']
group5 = group5.sort_values(['count'], ascending=False) #not sure what should be the cut off, should it be based on proportion instead?
#group5["proportion"] = group5["count"]/group5["total"]
#group5 = group1.sort_values(['proportion'], ascending=False) 

group6 = cluster_map[cluster_map.cluster == 6].groupby('group',as_index=False).count()
group6 = pd.merge(group6,base,on='group',how='inner')
group6.columns = ['category', 'count','total']
group6 = group6.sort_values(['count'], ascending=False) #not sure what should be the cut off, should it be based on proportion instead?
#group6["proportion"] = group6["count"]/group6["total"]
#group6 = group6.sort_values(['proportion'], ascending=False) 

group7 = cluster_map[cluster_map.cluster == 7].groupby('group',as_index=False).count()
group7 = pd.merge(group7,base,on='group',how='inner')
group7.columns = ['category', 'count','total']
group7 = group7.sort_values(['count'], ascending=False) #not sure what should be the cut off, should it be based on proportion instead?
#group7["proportion"] = group7["count"]/group7["total"]
#group7 = group7.sort_values(['proportion'], ascending=False) 

group8 = cluster_map[cluster_map.cluster == 8].groupby('group',as_index=False).count()
group8 = pd.merge(group8,base,on='group',how='inner')
group8.columns = ['category', 'count','total']
group8 = group8.sort_values(['count'], ascending=False) #not sure what should be the cut off, should it be based on proportion instead?
#group8["proportion"] = group8["count"]/group8["total"]
#group8 = group8.sort_values(['proportion'], ascending=False) 

group9 = cluster_map[cluster_map.cluster == 9].groupby('group',as_index=False).count()
group9 = pd.merge(group9,base,on='group',how='inner')
group9.columns = ['category', 'count','total']
group9 = group9.sort_values(['count'], ascending=False) #not sure what should be the cut off, should it be based on proportion instead?
#group9["proportion"] = group9["count"]/group9["total"]
#group9 = group9.sort_values(['proportion'], ascending=False) 

group10 = cluster_map[cluster_map.cluster == 10].groupby('group',as_index=False).count()
group10 = pd.merge(group10,base,on='group',how='inner')
group10.columns = ['category', 'count','total']
group10 = group1.sort_values(['count'], ascending=False) #not sure what should be the cut off, should it be based on proportion instead?
#group10["proportion"] = group10["count"]/group10["total"]
#group10 = group10.sort_values(['proportion'], ascending=False) 

group11 = cluster_map[cluster_map.cluster == 11].groupby('group',as_index=False).count()
group11 = pd.merge(group11,base,on='group',how='inner')
group11.columns = ['category', 'count','total']
group11 = group11.sort_values(['count'], ascending=False) #not sure what should be the cut off, should it be based on proportion instead?
#group11["proportion"] = group11["count"]/group11["total"]
#group11 = group11.sort_values(['proportion'], ascending=False)

## Overall Data

df['cluster'] = km.labels_
df['category'] = classes
df

